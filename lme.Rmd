---
title: "covid19-lmm-forecast-draft"
output: 
  #rmarkdown::github_document
  html_document:
    toc: true
    number_sections: true
    keep_md: true
---


```{r setup, include=F}
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
library(tidyverse)
library(magrittr)
library(nlme)
library(RCurl)


rm(list = ls())
```


# Downloading and getting data in shape

<br />

## Initial work

- First need to read in all.csv off Ken's GitHub page; to do this, load RCurl package to use getURL function w/in read.csv, as the csv file is embedded within an html file (typical for GitHub).

```{r datain, include=T}

alldata <-
  read.csv(text=getURL("https://raw.githubusercontent.com/kentranz/socialMobilityCOVID/master/data/all.csv"), 
           header=T)
## the above file has already been updated for standardized 
##    Apple mobility data, and various indicator variables for
##    dates of interest, as well as lagged cases variables, etc.
##    --> it has longitudinal data for 24 cities,
##          20 in US, and Toronto, Montreal, London, and Stockholm

str(alldata)
```

- Code to read in data and output from `str` call hidden from this output.  Most R code below for data manipulation will also be hidden from output, and only selective dataset elements will be displayed. Alternatively, R code for data analyses and resulting output will more generally be displayed.

- Will output variable names though:

```{r varlist, echo=FALSE}
names(alldata)
```

- Here, *newCases* will be converted into a rate, and this, and the first two days of lagged case rate values, will serve as the primary response and two predictors, respectively.

- The time variable will be a converted version of *date*.  This, and the previous bullet point will be worked on in the next subsection.


<br />

## Additional data manipulation

- Creating a US city indicator variable, i.e., 1 if US city, 0 for non-US city.

```{r manip1, include=FALSE}
alldata$city.ind <- 
  ifelse(alldata$city %in% c('London', 'Montreal', 'Stockholm', 'Toronto'), 
         0, 1)
```

### Play with dates

- First, note that not all 24 cities had counts available to us starting at earlier date in our dataset of March 1, 2019, while all cities had observations starting March 13th.  As of the November 14th end dataset (the one being worked on here), these earlier dates in March, for cities where they were not originally collected, were entered in original dataset as 0's.  This seems a reasonable choice given the very low or non-existent case counts in many cities at that time.  In addition, we will not be use data earlier than March 13th in our analyses, so those 0's are irrelevant for our work here.

- Dates are in character form, and need to change to numeric for modeling.

- Need to align all new day variable to min of observed dates, so day 0 will 2020-03-01, but will have a second new day variable that will be about 2 days after 2020-03-13 (make this the midpoint of March, i.e., March 16th), to allow for two days of lagged cases as predictors; the lagged 7-day mobility data is actually available since near Feb 1, if we ever need it.

- Aside from March 16th start date, we will make one for April 1st, and one that is based on a French study (Prague et al., 2020), which is dynamic based on specifically starting on the first day of cases for which it is followed by
at least 3 consecutive days of cases as well; this took longer to program.

- Will use *chron* package in R to help with dates and specifying initial origin at March 1st (day 0). As suggested on *chron* help page, use `options` argument to set default first day --- could do this twice to help create two sets of two columns, one where 03-01-20 is default and one for 03-16-20;
a 2nd option is to subset data when modeling such that all dates are
at least 03-16-20 when we want to have the later start/default date, which
will only affect the intercept interpretation; will take the 2nd approach
where day 15 (16th day), i.e., 03-16-20, will be first day w/ all complete data that accounts for two lagged cases days.

```{r manip2, include=FALSE}
library(chron)
# define origin day to be March 1st
options(chron.origin = c(month=3,day=1,year=2020))
# make one date column in chron date format:
alldata$date.chron <- chron(as.character(alldata$date), format = "y-m-d")
# make another date column in numeric format, calling it day
#   such that 2020-03-01 will be day 0
alldata$day <- as.numeric(alldata$date.chron)
# and make centered version of day, for use for any polynomial version of day
#   in model
alldata$day.c <- alldata$day - mean(alldata$day)
# can run table function to see what day variable looks like
table(alldata$day)
# make a new variable with March 16th as day 0 (instead of March 1st)
alldata$day031620 <- alldata$day - 15
# create centered version (which will be centered from March 16 onward)
alldata$day031620.c <- alldata$day031620 - 
  mean(alldata$day031620[alldata$day031620 >= 0])
# make April 1st as day 0 (instead of March 1st)
alldata$day040120 <- alldata$day - 31
# create centered version (which will be centered from April 1 onward)
alldata$day040120.c <- alldata$day040120 - 
  mean(alldata$day040120[alldata$day040120>=0])
```

- Here is where French start day will be defined, which will be the 1st day that at least 4 consecutive days of cases start.  Code will identify sequences in a vector.  Output prints first day of French method in each city.

```{r manip3, echo=FALSE}
#dayFM means day according to French method
alldata$dayFM <- rep(NA, length(alldata$day))
alldata$dayFM.c <- rep(NA, length(alldata$day))

cnt <- 1
m <- with(alldata, length(unique(city)))
for(i in 1:m)
{
  s <- with(alldata, 
            paste(sign(newCases[city == unique(city)[i]]), collapse = ""))
  g <- gregexpr("1{4,}", s)[[1]]
  # print out only the first day in which a string of at least four 
  #   consecutive non-zero case days occur; need g[1] or else any
  #   new consecutive sequence of at least 4, following a new 0, will also print
  #   --> below line indeed prints out the correct date:
  #   print(with(alldata, date.chron[city == unique(city)[i]][g[1]])[[1]])
  
  # now, borrowing some scripting code from above commented line, start 
  #   "French method (FM)" day 0 at the g[1] date,
  #   with subtraction of day[1] for each city needed to get day 0 to
  #   be first day in sequence of cases of at least four days:
  
  x <- with(alldata, length(day[city == unique(city)[i]]))
  alldata$dayFM[cnt:(cnt+x-1)] <- 
    alldata$day[cnt:(cnt+x-1)] - g[1] + 1 - alldata$day[cnt]
  alldata$dayFM.c[cnt:(cnt+x-1)] <- 
    alldata$dayFM[cnt:(cnt+x-1)] - 
    mean(alldata$dayFM[cnt:(cnt+x-1)][alldata$dayFM[cnt:(cnt+x-1)]>=0])
  cnt <- cnt + x
}

# print out each city and their FM (French method) start date
m <- with(alldata, length(unique(city)))
city.FM <- with(alldata, unique(city))
startdate.FM <- as.dates(rep(NA, m)) # ensuring we keep dates format from chron

for(i in 1:m)
{
  startdate.FM[i] <- 
    with(alldata, date.chron[(city==(unique(city)[i])) & dayFM==0])
}

FM.info <- data.frame(city.FM, startdate.FM)
FM.info
```

- Dec 17 2020:  The above all provided, it should be mentioned that the use of the French method and start dates other than 03-16-20 will be put off for potential future use.


### Creating case rates

- Making another column in dataset, which is a rate, i.e.,
    number of cases per 100000 people in population.  This will
    be the longitudinal response variable in our graphing and modeling.
    To do this, taking *newCases*, divide by Population (in city), and      multiplying by 100000; will do this for *caseTminus1* and *caseTminus2*         variables as well:

```{r manip4, echo=FALSE}
alldata$case.rate <- alldata$newCases * 100000 / alldata$Population 
alldata$casesTminus1.rate <- 
  alldata$casesTminus1 * 100000 / alldata$Population
alldata$casesTminus2.rate <- 
  alldata$casesTminus2 * 100000 / alldata$Population
```



# Start longitudinal work

<br />

## Initial graphing

- Start with using *nlme* library, created so-called groupedData objects, which benefit both graphing and modeling using the `lme` function (and other modeling functions) within *nlme*.

```{r grouped, include=FALSE}
library(nlme)
# first, for raw data
alldata.grouped <- groupedData(newCases ~ day | city, outer = ~ city.ind,
                      labels = list(x = 'time (in days, since March 1 2020)',
                                    y = 'daily case count'),
                                    data = alldata)
# second, and what we will use in modeling, the case rate data
alldata.groupedR <- groupedData(case.rate ~ day | city, outer = ~ city.ind,
                      labels = list(x = 'time (in days, since March 1 2020)',
                                    y = 'daily case rate per 100000'),
                                    data = alldata)
# look at first few record of rate data
head(alldata.groupedR)  # not printed in this R chunk
```

- Create plots from groupedData objects; nlme generic plotting on these objects uses Trellis graphs here.

```{r plot_group, echo=FALSE}
# plot city trajectories of (raw) daily cases
 plot(alldata.grouped, 
     main='city time-series of daily new case counts')
# plot city trajectories of daily case rates per 100000
plot(alldata.groupedR, 
     main='city time-series of daily case rates per 100000')
```



# Global start date
```{r}
startDate <- as.Date('2020-03-22')
```


# Mar-Aug

## Data partition
```{r}
cutOff <- as.Date("2020-08-31")

testRange <- 14

```

## LME
```{r}

modelName = 'lmeAug_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lme(fixed = case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend,
    random = ~ casesTminus1.rate + casesTminus2.rate - 1 | city,
    data = train
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
         
         


# Predict one new observation at a time
# For each new 7-day period, refit the model with actual observed Y
for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  #print(i)
  #print(model)
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  
  tempTest <- test %>% 
    filter(as.Date(date) == cutOff + i)
  
  tempTest$pred <- predict(model, newdata = tempTest)

  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
  
  # clean up extra columns after join 
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics <- metrics

```


## LM
```{r}
modelName <- 'lmAug_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
         
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- pred$fit
  tempTest$lowerCI <- pred$lwr
  tempTest$upperCI <- pred$upr
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```



## LME + Walking
```{r}

modelName = 'lmeWalkingAug_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lme(fixed = case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend + walkingMinus7,
    random = ~ casesTminus1.rate + casesTminus2.rate - 1 | city,
    data = train
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
         
         


# Predict one new observation at a time
# For each new 7-day period, refit the model with actual observed Y
for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  #print(i)
  #print(model)
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  
  tempTest <- test %>% 
    filter(as.Date(date) == cutOff + i)
  
  tempTest$pred <- predict(model, newdata = tempTest)

  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
  
  # clean up extra columns after join 
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics %<>% 
  left_join(metrics, by = "city")

```


## LM + Walking
```{r}
modelName <- 'lmWalkingAug_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend + walkingMinus7,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
         
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- pred$fit
  tempTest$lowerCI <- pred$lwr
  tempTest$upperCI <- pred$upr
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```






## LME-Log
```{r}

modelName = 'lmeLogAug_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))


model <- lme(fixed = log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend,
    random = ~ log(casesTminus1.rate) + log(casesTminus2.rate) - 1 | city,
    data = train
    , control = lmeControl(maxIter = 1e8, opt='optim') 
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )

for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  # filter test set to calculate pred for only 1 day at a time
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)
  tempTest$pred <- predict(model, newdata = tempTest)
  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  tempTest %<>% 
    mutate(pred = exp(pred)
           , lowerCI = exp(lowerCI)
           , upperCI = exp(upperCI)
           )
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics %<>% 
  left_join(metrics, by = "city")

```

## LM-Log
```{r}
modelName <- 'lmLogAug_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- exp(pred$fit)
  tempTest$lowerCI <- exp(pred$lwr)
  tempTest$upperCI <- exp(pred$upr)
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }

  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```



## LME-Log + Walking
```{r}

modelName = 'lmeLogWalkingAug_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))


model <- lme(fixed = log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend + walkingMinus7,
    random = ~ log(casesTminus1.rate) + log(casesTminus2.rate) - 1 | city,
    data = train
    , control = lmeControl(maxIter = 1e8, opt='optim') 
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )

for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  # filter test set to calculate pred for only 1 day at a time
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)
  tempTest$pred <- predict(model, newdata = tempTest)
  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  tempTest %<>% 
    mutate(pred = exp(pred)
           , lowerCI = exp(lowerCI)
           , upperCI = exp(upperCI)
           )
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics %<>% 
  left_join(metrics, by = "city")

```

## LM-Log + Walking
```{r}
modelName <- 'lmLogWalkingAug_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend + walkingMinus7,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- exp(pred$fit)
  tempTest$lowerCI <- exp(pred$lwr)
  tempTest$upperCI <- exp(pred$upr)
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }

  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```







# Mar-Nov

## Data partition
```{r}
cutOff <- as.Date("2020-11-30")

testRange <- 14

```

## LME
```{r}

modelName = 'lmeNov_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lme(fixed = case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend,
    random = ~ casesTminus1.rate + casesTminus2.rate - 1 | city,
    data = train
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )


# Predict one new observation at a time
# For each new test, refit the model with actual observed Y
for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  # filter test set to calculate pred for only 1 day at a time
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)
  tempTest$pred <- predict(model, newdata = tempTest)
  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )  
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics %<>% 
  left_join(metrics, by = "city")

```


## LM
```{r}
modelName <- 'lmNov_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- pred$fit
  tempTest$lowerCI <- pred$lwr
  tempTest$upperCI <- pred$upr
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }

  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```



## LME + walking
```{r}

modelName = 'lmeWalkingNov_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lme(fixed = case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend + walkingMinus7,
    random = ~ casesTminus1.rate + casesTminus2.rate - 1 | city,
    data = train
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )


# Predict one new observation at a time
# For each new test, refit the model with actual observed Y
for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  # filter test set to calculate pred for only 1 day at a time
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)
  tempTest$pred <- predict(model, newdata = tempTest)
  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )  
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics %<>% 
  left_join(metrics, by = "city")

```


## LM
```{r}
modelName <- 'lmWalkingNov_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(case.rate ~ casesTminus1.rate + casesTminus2.rate + weekend + walkingMinus7,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- pred$fit
  tempTest$lowerCI <- pred$lwr
  tempTest$upperCI <- pred$upr
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }

  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```




## LME-Log
```{r}

modelName = 'lmeLogNov_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))


model <- lme(fixed = log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend,
    random = ~ log(casesTminus1.rate) + log(casesTminus2.rate) - 1 | city,
    data = train
    , control = lmeControl(maxIter = 1e8, opt='optim') 
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )


# Predict one new observation at a time
# For each new test, refit the model with actual observed Y
for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  # filter test set to calculate pred for only 1 day at a time
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)
  tempTest$pred <- predict(model, newdata = tempTest)
  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  tempTest %<>% 
    mutate(pred = exp(pred)
           , lowerCI = exp(lowerCI)
           , upperCI = exp(upperCI)
           )
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics %<>% 
  left_join(metrics, by = "city")

```

## LM-Log
```{r}
modelName <- 'lmLogNov_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- exp(pred$fit)
  tempTest$lowerCI <- exp(pred$lwr)
  tempTest$upperCI <- exp(pred$upr)
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }

  test %<>% 
  mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
         , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
         )
  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```



## LME-Log + Walking
```{r}

modelName = 'lmeLogWalkingNov_' 

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))


model <- lme(fixed = log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend + walkingMinus7,
    random = ~ log(casesTminus1.rate) + log(casesTminus2.rate) - 1 | city,
    data = train
    , control = lmeControl(maxIter = 1e8, opt='optim') 
    )
summary(model)

# test to hold all date data points up to testRange
test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )


# Predict one new observation at a time
# For each new test, refit the model with actual observed Y
for (i in 1:testRange)
{
  
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  # test to check correct training window
  # print(i)
  # print(max(as.Date(train$date)))
  
  # filter test set to calculate pred for only 1 day at a time
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)
  tempTest$pred <- predict(model, newdata = tempTest)
  
  # test to check for correct test window
  # print(max(as.Date(tempTest$date)))
  
  # create design matrix
  # [-2] drops response from formula
  Designmat <- model.matrix(formula(model)[-2], tempTest)
  
  # compute XVX′ to get the variance-covariance matrix of the predictions
  # extract the diagonal of this matrix to get variances of predictions
  predvar <- diag(Designmat %*% vcov(model) %*% t(Designmat)) 
  #results7$SE <- sqrt(predvar) 
  tempTest$SE <- sqrt(predvar + model$sigma^2) # sigma is the estimated within-group error standard deviation
  tempTest$lowerCI <- tempTest$pred - 1.96*tempTest$SE
  tempTest$upperCI <- tempTest$pred + 1.96*tempTest$SE
  
  tempTest %<>% 
    mutate(pred = exp(pred)
           , lowerCI = exp(lowerCI)
           , upperCI = exp(upperCI)
           )
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }
  
  # bring forward predictions
  test %<>% 
    mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
           , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
           )
}



# pull all metrics into one dataframe called dailyMetrics
metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))

dailyMetrics %<>% 
  left_join(metrics, by = "city")

```

## LM-Log + Walking
```{r}
modelName <- 'lmLogWalkingNov_'

train <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff))

model <- lm(log(case.rate) ~ log(casesTminus1.rate) + log(casesTminus2.rate) + weekend + walkingMinus7,
    data = train
    )
summary(model)

test <- alldata.groupedR %>% 
  filter(as.Date(date) >= startDate 
       & as.Date(date) > cutOff
       & as.Date(date) <= (cutOff + testRange)
       ) %>%
  select(city, day031620, date, weekend, case.rate, casesTminus1.rate, casesTminus2.rate, walkingMinus7) %>%
  mutate(
    casesTminus1.rate = case_when( mod(as.numeric(as.Date(date) - cutOff), 7) == 1 ~ casesTminus1.rate
         , TRUE ~ as.numeric(NA))
    , casesTminus2.rate = 
           case_when( mod(as.numeric(as.Date(date) - cutOff), 7) %in% c(1,2) ~ casesTminus2.rate
         , TRUE ~ as.numeric(NA))
         )
  
for (i in 1:testRange)
{
  if(i >1 & i %% 7 == 1) # update only when predicting on 8th, 15th, etc. days
  {
    train <- alldata.groupedR %>% 
      filter(as.Date(date) >= startDate & as.Date(date) <= (cutOff - 1 + i))

    model <- update(model, data = train)
  }
  
  
  tempTest <- test %>% filter(as.Date(date) == cutOff + i)

  pred <- predict(model, newdata = test[i,], interval = "prediction", level = 0.95) %>% as.data.frame()
  tempTest$pred <- exp(pred$fit)
  tempTest$lowerCI <- exp(pred$lwr)
  tempTest$upperCI <- exp(pred$upr)
  
  test %<>%
    left_join(tempTest %>% select(city, date, pred, lowerCI, upperCI)
              , by = c("date" = "date", "city" = "city"))
   
  if(i > 1)
  {
    test %<>% 
      mutate(pred = coalesce(pred.x, pred.y)
             , lowerCI = coalesce(lowerCI.x, lowerCI.y)
             , upperCI = coalesce(upperCI.x, upperCI.y)
             ) %>%
      select(-pred.x, -pred.y
             , -lowerCI.x, -lowerCI.y
             , -upperCI.x, -upperCI.y)
  }

  test %<>% 
  mutate(casesTminus1.rate =  case_when(is.na(casesTminus1.rate) ~ lag(as.numeric(pred)), TRUE ~ casesTminus1.rate)
         , casesTminus2.rate =  case_when(is.na(casesTminus2.rate) ~ lag(as.numeric(pred), 2), TRUE ~ casesTminus2.rate)
         )
  
}

metrics <- test %>% 
    filter(as.Date(date) <= cutOff + 7) %>%
    group_by(city) %>% 
    summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
              , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
              , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
              ) %>%
    left_join( test %>% 
                 group_by(city) %>% 
                 summarize(MAE = round(mean(abs(case.rate - pred)) , 2)
                           , MAPE = round(mean(abs(case.rate - pred)/case.rate) , 2)
                           , CP = round(sum(case.rate >= lowerCI & case.rate <= upperCI ) / n() , 2)
                           )
               , by = "city"
               , suffix = c("_7d", "_14d")
               ) %>%
    rename_at(vars(-city), ~ paste0(modelName,.)) %>%
    arrange(as.character(city))


dailyMetrics %<>% 
  left_join(metrics, by = "city")

```






# Metrics
```{r}
print(dailyMetrics %>% as.data.frame())

write.csv(dailyMetrics
          , file = paste0(rstudioapi::selectDirectory(), '/dailyMetrics.csv'))
```























































